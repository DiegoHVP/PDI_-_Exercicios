:source-highlighter: pygments
:stem:
:toc:
:icons: font

= Processamento digital de imagens
Diêgo Henrique Viana Pereira <diego.henrique.706@ufrn.edu.br>

:sectnums:
== Introdução

Este site se destina a apresentação da solução dos exercícios propostos na disciplina de Processamento Digital de Imagens (DCA0445) disponibilizado pelo Departamento de Engenharia de Computação e Automação da UFRN e ministrado pelo professor Agostinho Brito, cujo curso se encontra disponível em <https://agostinhobritojr.github.io/tutorial/pdi/>.

Todos os exercícios a seguir foram desenvolvidos em C++, juntamente com a biblioteca OpenCV <https://opencv.org/>, compilados usando o _Makefile_ disponibilizado no site do curso. Para compilar e executar os códigos precisamos usar os seguintes comandos:
crie uma arquivo com um nome qualquer e adicione o codigo desejado, na mesma pasta crie um outro arquivo chamado CMakeLists.txt e adicione o seguinte codigos:  
[source,cmake]
----
cmake_minimum_required(VERSION 3.0.0)
project(<nome_do_arquivo_do_codigo> VERSION 0.1.0 LANGUAGES C CXX)

find_package(OpenCV REQUIRED)
include_directories(${OpenCV_INCLUDE_DIRS})

add_executable(<nome_do_arquivo_do_codigo> <nome_do_arquivo_do_codigo>.cpp)
target_link_libraries(<nome_do_arquivo_do_codigo> ${OpenCV_LIBS})
----

Feito isso, basta executar no terminal:
[source,bash]
----
$ mkdir build
$ cd build
$ CMakeLists ..
$ make
----
Assim você tera um executavel do codigo.

== Capitulo 02 - Manipulando pixels em uma imagem

Neste tópico vemos como abrir e exibir uma imagem, além de acessar e modificar seus pixels, usando as ferramentas acima.

=== Exercício *_Regiões_*

Usando `U1/CH2 - Manipulando pixels em uma imagem/negativo/regioes.cpp` como referência, foi implementado um algorítmo que recebe uma imagem (passando-a para escala de cinza) e inverte as cores de uma região definida pelas coordenadas de dois pontos.


[source,cpp]
----
include::U1/CH2 - Manipulando pixels em uma imagem/negativo/regioes.cpp[]
----


[#img-regioes]
.Resultado da execução do programa regions.cpp 
image::U1/CH2 - Manipulando pixels em uma imagem/negativo/result/resultado.png[Resultado]

=== Exercício *_Troca de regiões_*

Neste tópico foi implementado um programa que troca as regiões da imagem (convertida em tons de cinza) fornecida. Nesse exemplo foi explorado o uso de uma função disponível no OpenCV para extrair regiões de uma imagem e outra que permite a cópia de uma Matriz em outra.

[source,cpp]
----
include::U1/CH2 - Manipulando pixels em uma imagem/trocaRegioes/trocaRegioes.cpp[]
----

[#img-trocaregioes]
.Resultado da execução do programa trocaregioes.cpp
image::U1/CH2 - Manipulando pixels em uma imagem/trocaRegioes/lena.png[Resultado]

== Capitulo 11 - Preenchendo regiões

Nessa seção aprendemos sobre o algorítmo _floodfill_, usado para preencher regiões, e o aplicamos em um programa que contabiliza as bolhas e as bolas brancas em uma imagem de fundo preto.

[source,cpp]
----
include::U1/CH11 - Preenchendo regioes/fillLocals.cpp[]
----

[#img-labeling]
.Etapas da execução e resultado do programa fillLocals.cpp
image::U1/CH11 - Preenchendo regioes/labeling.png[Resultado]

= Capitulo 10 - Decomposição de imagen em plano de bits

Neste tópico vemos como abrir pegar uma imagem e embutir em outra, isso é possivel a unidade usada para representação de cores (unchar) possui 8 bits com isso podemos usar os bits mais significatvos de uma imagem e adicionalos nos bits menos significativos de outra.

=== Codifica

Foi implementado um algorítmo que recebe 2 imagem, uma imagem portadora e uma a ser escondida, ao executar introzuimos parte de uma imagem na outra.


[source,cpp]
----
include::U1/CH10 - Decomposicao de imagens em planos de bits/codificar/codificar.cpp[]
----

[#img-codificar]
image::U1/CH10 - Decomposicao de imagens em planos de bits/codificar/build/esteganografia.png[Resultado]

=== Decodificar

Foi implementado um algoritmo que retira os bits menos significativos e repoem em uma outra imagem como os bits mais significativos decodificando a imagem que foi anteriormente imbutuda

[source,cpp]
----
include::U1/CH10 - Decomposicao de imagens em planos de bits/decodificar/recup_img.cpp[]
----
[#img-decodificar]
image::U1/CH10 - Decomposicao de imagens em planos de bits/decodificar/decodificada.png[Resultado]

== Filtragem no domínio da frequência

Nessa seção aprendemos a passar imagens do domínio espacial para o domínio da frequência (e vice-versa) utilizando a Transformada discreta de Fourier e como podemos usar filtros nesse domínio.

=== Exercício *_filtro homomórfico_*

Usando o programa exemplos/dft.cpp como base, implementamos o filtro homomórfico stem:[H(u, v)] que tem o objetivo de corrigir a iluminação de uma imagem em tons de cinza. Ele foi construído usando a fórmula abaixo:

stem:[H(u, v) = (\gamma_H - \gamma_L)(1 - \exp{-c({D(u, v)^{2}}/D_{0}^2)}) + \gamma_L]

Em que stem:[\gamma_L, \gamma_H, D_0] e stem:[c] são as constantes que definem o comportamento do filtro em função da distância do seu centro stem:[D(u, v)].

[#img-filtrohomomorfico]
.Filtro homomórfico gerado com parâmetros usados no programa abaixo.
image::imagens/figura91.png[Resultado]

Para aplicá-lo, primeiramente redimensionamos a imagem para que sua altura e largura sejam potência de 2 e preenchemos o espaço extra com zeros (_padding_) o que possibilita o uso da FFT sem afetar a imagem. Em seguida, efetuamos a operação de `log` na imagem (tanto na parte real como complexa) somada em um para evitar o cálculo de stem:[log(0)]. Então realizamos a Tranformada de Fourier, deslocamos o espectro, multiplicamos o filtro com o espectro e então fazemos a operação inversa. Por fim, efetuamos o `exp` na imagem e a normalizamos para exibição.

[source, cpp]
----
#include <iostream>
#include <cmath>
#include <opencv2/opencv.hpp>
#include <opencv2/core.hpp>
#include <opencv2/imgproc/imgproc.hpp>

//Valores escolhidos esperimentalmente
#define gH 1.7
#define gL 0.6
#define c 0.3
#define d0 7

using namespace cv;
using namespace std;

// troca os quadrantes da imagem da DFT
void deslocaDFT(Mat& image ){
  Mat tmp, A, B, C, D;

  // se a imagem tiver tamanho impar, recorta a regiao para
  // evitar cópias de tamanho desigual
  image = image(Rect(0, 0, image.cols & -2, image.rows & -2));
  int cx = image.cols/2;
  int cy = image.rows/2;

  // reorganiza os quadrantes da transformada
  // A B   ->  D C
  // C D       B A
  A = image(Rect(0, 0, cx, cy));
  B = image(Rect(cx, 0, cx, cy));
  C = image(Rect(0, cy, cx, cy));
  D = image(Rect(cx, cy, cx, cy));

  // A <-> D
  A.copyTo(tmp);  D.copyTo(A);  tmp.copyTo(D);

  // C <-> B
  C.copyTo(tmp);  B.copyTo(C);  tmp.copyTo(B);
}

int main(int argc, char** argv){
  Mat imaginaryInput, complexImage;
  Mat padded, filter, filter_print;
  Mat image, tmp;
  Mat_<float> zeros;
  vector<Mat> planos, filtros, dfts;

  int dft_M, dft_N;

  image = imread(argv[1], CV_LOAD_IMAGE_GRAYSCALE);
  imshow("filtrada", image);
  waitKey();
  
  // identifica os tamanhos otimos para
  // calculo do FFT
  dft_M = getOptimalDFTSize(image.rows);
  dft_N = getOptimalDFTSize(image.cols);

  // realiza o padding da imagem
  copyMakeBorder(image, padded, 0,
                 dft_M - image.rows, 0,
                 dft_N - image.cols,
                 BORDER_CONSTANT, Scalar::all(0));

  // prepara a matriz complexa e preenche com 0
  imaginaryInput = Mat(padded.size(), CV_32FC1, Scalar(0));
  
  //Trasforma padded em float
  padded.convertTo(padded, CV_32F);
  
  normalize(padded, padded, 0.0, 1.0, NORM_MINMAX);
  
  //Soma ambas as componentes com 1 para evitar a operação ln(0)
  cv::log(padded + 1, padded);
  cv::log(imaginaryInput + 1, imaginaryInput);  

  //Concatena plano real e imaginário para realizar a DFT
  planos.push_back(padded);
  planos.push_back(imaginaryInput);

  merge(planos, complexImage);

  // Construindo a função de transferência (filtro frequencial) com o
  // mesmo tamanho e tipo da matriz complexa
  filter = Mat((dft_M & -2), (dft_N & -2), CV_32FC2, Scalar(0, 0));

  // Preenche o filtro homomórfico com os valores dadod pela função
  for(int i=0; i< dft_M; i++){
    for(int j=0; j < dft_N; j++){
      float h = (float) (gH - gL)*(1.0 - exp(-c*(pow(abs(i-dft_M/2)+abs(j-dft_N/2), 2)/pow(d0, 2)))) + gL;
      filter.at<Vec2f>(i, j)[0] = h;
      filter.at<Vec2f>(i, j)[1] = h;
    }
  }

  split(filter, filtros);
  normalize(filtros[0], filter_print, 0.0, 1.0, CV_MINMAX);
  imshow("filtro", filter_print);
  waitKey();

  // Efetua a filtragem
  dft(complexImage, complexImage);
  deslocaDFT(complexImage);
  mulSpectrums(complexImage,filter,complexImage,0);
  deslocaDFT(complexImage);
  idft(complexImage, complexImage, DFT_SCALE);

  cv::exp(complexImage,complexImage);  

  planos.clear();
  split(complexImage, planos);

  // normaliza a parte real para exibicao
  normalize(planos[0], tmp, 0.0, 1.0, CV_MINMAX);
  imshow("imagem_final", tmp);
  waitKey();
  return 0;
}
----

[#img-aplicacaohomomorfico]
.Comparação entre uma imagem antes e depois da aplicação do filtro homomórfico.
image::imagens/figura9.png[Resultado]

Após a aplicação do filtro, percebemos que o brilho da imagem está mais equilibrado.

== Detecção de bordas com o algoritmo de Canny

Nessa seção, vimos a implementação do detecctor de bordas de Canny funciona e como usá-lo no _OpenCV_.

=== Exercício *_cannypoints_*

Usando os programa exemplos/canny.cpp e exemplos/pontilhismo.cpp como base, implementamos um algoritmo que gera um efeito pontilhista em uma imagem fornecida usando o algoritmo de Canny para aumentar sua qualidade. Isso foi feito desenhando círculos menores (dois pixels de raio em comparação com os cinco usados na geração da imagem pontilhista inicial) em cima das posições que o algoritmo indicou como borda.

[source, cpp]
----
#include <iostream>
#include "opencv2/opencv.hpp"
#include <algorithm>
#include <vector>
#include <ctime>
#include <numeric>

using namespace std;
using namespace cv;

#define STEP 4
#define JITTER 3
#define RAIO 5
#define RAIO_PEQUENO 2

int main(int argc, char **argv)
{
  int width, height, limite_inferior = 80;
  int x, y;
  vector<int> xrange, yrange;
  vector<Vec6i> pontos;
  Mat points, image, border, image_bw;
  Vec3b gray;

  image = imread(argv[1], CV_LOAD_IMAGE_COLOR);

  cvtColor(image, image_bw, CV_BGR2GRAY);

  width = image.size().width;
  height = image.size().height;

  //Aplica o algoritmo de canny na imagem
  Canny(image_bw, border, limite_inferior, 3 * limite_inferior);
  imshow("bordas_canny", border);
  waitKey();

  //Obtem imagem pontilhista
  xrange.resize(height / STEP);
  yrange.resize(width / STEP);

  iota(xrange.begin(), xrange.end(), 0);
  iota(yrange.begin(), yrange.end(), 0);

  //Realiza amostragem dos pontos
  for (uint i = 0; i < xrange.size(); i++)
  {
    xrange[i] = xrange[i] * STEP + STEP / 2;
  }

  for (uint i = 0; i < yrange.size(); i++)
  {
    yrange[i] = yrange[i] * STEP + STEP / 2;
  }

  points = Mat(height, width, CV_8UC3, Scalar(255, 255, 255));

  random_shuffle(xrange.begin(), xrange.end());

  for (auto i : xrange)
  {
    random_shuffle(yrange.begin(), yrange.end());
    for (auto j : yrange)
    {
      x = i + rand() % (2 * JITTER) - JITTER + 1;
      y = j + rand() % (2 * JITTER) - JITTER + 1;

      //Impede o algoritmo de pegar pontos além dos limites da imagem
      if (x >= height)
      {
        x = height - 1;
      }
      if (y >= width)
      {
        y = width - 1;
      }

      gray = image.at<Vec3b>(x, y);
      circle(points,
             cv::Point(y, x),
             RAIO,
             Scalar(gray[0], gray[1], gray[2]),
             -1,
             CV_AA);
    }
  }

  imshow("imagem_pontilhista", points);
  waitKey();

  //Percorre matriz em busca da borda gerada pelo algoritmo de canny para
  //desenhar pontos pequenos
  for (int i = 0; i < height; i++)
  {
    for (int j = 0; j < width; j++)
    {
      if (border.at<uchar>(i, j) != 0)
      {
        //Armazena a cor origina do ponto, bem como sua posição na
        //estrutura Vec6i, que armazena 6 inteiros
        gray = image.at<Vec3b>(i, j);
        pontos.push_back(Vec6i(j, i, gray[0], gray[1], gray[2], 0));
      }
    }
  }

  random_shuffle(pontos.begin(), pontos.end());

  //Desenha pontos pequenos na imagem
  Scalar cor;
  for (int i = 0; i < pontos.size(); i++)
  {
    Point p(pontos.at(i)[0], pontos.at(i)[1]);
    cor = Scalar(pontos.at(i)[2], pontos.at(i)[3], pontos.at(i)[4]);
    circle(points,
           p,
           RAIO_PEQUENO,
           cor,
           -1,
           CV_AA);
  }

  imshow("imagem_pontilhista_corrigida", points);
  waitKey();

  imwrite("cannyborders.png", points);
  return 0;
}
----

[#img-pontilhismomelhor]
.Imagem pontilhista antes e depois do processo de melhora na qualidade.
image::imagens/figura10.png[Resultado]

== Quantização vetorial com _k-means_

Nessa seção, aprendemos sobre o funcionamento desse algoritmo de agrupamento e sua utilização no _OpenCV_

=== Exercício *_kmeans_*

Com base no programa kmeans.cpp, fizemos um programa que executa `nRodadas` vezes o algoritmo _k-means_ em uma imagem iniciando os centros de forma aleatória. 

[source, cpp]
----
#include <opencv2/opencv.hpp>
#include <cstdlib>
#include <vector>
#include <iostream>
#include <GraphicsMagick/Magick++.h> //Biblioteca responsável pela geração do GIF

using namespace std;
using namespace cv;

int main( int argc, char** argv ){
  Magick::InitializeMagick(NULL);
  int nClusters = 6;
  Mat rotulos;
  int nRodadas = 1;
  int nExecucoes = 10;
  Mat centros;

  if(argc!=3){
	  exit(0);
  }
  
  //Efetua leitura da imagem
  Mat img = imread( argv[1], CV_LOAD_IMAGE_COLOR);
  Mat samples(img.rows * img.cols, 3, CV_32F);

  //Insere cada pixel da matriz da imagem em um vetor
  for( int y = 0; y < img.rows; y++ ){
    for( int x = 0; x < img.cols; x++ ){
      for( int z = 0; z < 3; z++){
        samples.at<float>(y + x*img.rows, z) = img.at<Vec3b>(y,x)[z];
	    }
	  }
  }
  
  //Executa o kmeans nExecucoes vezes, inserindo-os no vetor rotulada
  vector<Mat> rotulada(nExecucoes,  Mat(img.size(), img.type()) );
  vector<Magick::Image> criarGif;
  for(int i = 0; i<nExecucoes; i++){      
    kmeans(samples,
          nClusters,
          rotulos,
          TermCriteria(CV_TERMCRIT_ITER|CV_TERMCRIT_EPS, 10000, 0.0001),
          nRodadas,
          KMEANS_RANDOM_CENTERS,
          centros );

    for( int y = 0; y < img.rows; y++ ){
      for( int x = 0; x < img.cols; x++ ){ 
        int indice = rotulos.at<int>(y + x*img.rows,0);
        rotulada.at(i).at<Vec3b>(y,x)[0] = (uchar) centros.at<float>(indice, 0);
        rotulada.at(i).at<Vec3b>(y,x)[1] = (uchar) centros.at<float>(indice, 1);
        rotulada.at(i).at<Vec3b>(y,x)[2] = (uchar) centros.at<float>(indice, 2);
      }
    }

    imshow( "Imagem Clusterizada", rotulada.at(i) );
    waitKey(50);

    //Converte a imagem de cv:Mat para Magick::Image, definindo que cada quadro 
    //da animação terá duração de 500ms
    criarGif.push_back(Magick::Image(img.cols, 
                                      img.rows,
                                      "BGR",
                                      Magick::StorageType::CharPixel, 
                                      (char *)rotulada.at(i).data));
    criarGif.back().animationDelay(50);
  }

  //Gera o gif, colocando-o no arquivo "saidaKmeans.gif"
  Magick::writeImages(criarGif.begin(), criarGif.end(), "saidaKmeans.gif");
}
----

No fim é gerado um GIF animado para compararmos os resultados de cada iteração. Isso foi possivel por meio da instalação do _GraphicMagick_ por meio da linha de comando abaixo e da modificação do arquivo link:programs/Makefile[Makefile] para que código pudesse ser compilado.

[source, bash]
----
$ sudo apt install libgraphicsmagick++1-dev 
----

[#img-saidakmeans]
.Saída das `nRodadas` do kmeans.
image::imagens/figura11.gif[Resultado]

Como os centros dos agrupamentos são escolhidos de forma aleatória, esses pontos mudam a cada rodada, o que pode gerar imagens diferentes, conforme vemos no GIF acima.

:!sectnums: